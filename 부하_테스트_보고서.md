# 부하 테스트 스크립트 작성 및 수행

> < 테스트 환경 >   
> 모델명:	Samsung Galaxy Book Pro 4   
칩:	Intel i7-1255U   1.70 GHz   
총 코어 개수:	10개   
메모리:	32 GB   
> 성능 테스트 툴 : K6

## 콘서트 예약 서비스 주요 API

- 토큰 발급 API
- 대기열 조회 API
- 콘서트 목록 조회 API
- 콘서트 날짜 조회 API
- 콘서트 좌석 목록 조회 API
- 콘서트 예약 API
- 결제 API
- 포인트 충전 API
- 포인트 잔액 조회 API

### 테스트 방법 선정

1. Load Test (부하 테스트):
    - 일반적으로 **GET** 요청을 사용하는 API 엔드포인트에 적합합니다.
    - 여러 사용자가 동시에 접근하는 경우에 시스템이 얼마나 잘 견딜 수 있는지 평가하는 데 사용됩니다.
    - API가 자주 호출되거나 기본적인 상태를 확인할 때 사용됩니다.
2. Endurance Test (내구성 테스트):
    - 시스템의 메모리 누수나 성능 저하를 감지하기 위해 장기간 호출되는 API에 적합합니다.
    - 장기간의 사용 시 시스템에 어떤 영향이 있는지 확인해야 하는 **상태 유지형 API** 또는 **긴 세션을 필요로 하는 API**에 적합합니다.
3. Stress Test (스트레스 테스트):
    - 부하가 점진적으로 증가할 때 성능 한계가 있는지 확인해야 하는 API에 적합합니다.
    - **데이터 처리량이 높은 POST/PUT 요청** 또는 **복잡한 비즈니스 로직을 포함한 API**에 대해 수행됩니다.
4. Peak Test (최고 부하 테스트):
    - **가장 중요한 엔드포인트**에 대해 단시간에 최고 부하를 걸어서 서비스가 안정적인지 평가하는 데 사용됩니다.
    - 일반적으로 이벤트가 발생하거나 대규모 트래픽이 몰리는 경우를 시뮬레이션할 때 사용됩니다.

## 부하 테스트 대상

- 트래픽 집중 예상 기능: 사용자 트래픽이 집중될 가능성이 높은 API
- 성능 임계점이 중요한 기능: 높은 성능이 필수적이며, 응답 시간이 중요한 API
- 핵심 비즈니스 로직 관련 기능: 서비스의 핵심 기능으로, 높은 가용성과 성능을 보장해야 하는 API

### 부하 테스트 대상 API

1. 토큰 발급 API
- 사용자 인증을 위해 모든 요청에 앞서 호출되는 API로, 높은 호출 빈도를 가짐
- 응답 지연 시 전체 서비스 사용에 영향을 줄 수 있음

2. 콘서트 좌석 목록 조회 API
- 예약 전 좌석 선택 단계에서 많은 사용자가 동시에 접근할 것으로 예상
- 빠른 응답이 요구되며, 좌석 상태 동기화가 중요한 기능

3. 콘서트 예약 API
- 예상 트래픽이 가장 높은 기능으로, 대량의 동시 요청이 발생할 수 있음
- 좌석의 실시간 예약 처리 및 동시성 제어가 중요한 핵심 기능

4. 포인트 충전 API
- 결제 수단으로 사용되며, 충전 트랜잭션의 신속한 처리가 필요함
- 대규모 이벤트 또는 할인 기간에 사용량이 급증할 가능성이 있음

## 부하 테스트 목표
- 각 API의 최대 처리 용량과 임계점을 파악하고, 성능을 최적화하기 위한 데이터를 수집한다
- 서비스 안정성을 보장하기 위해 다양한 시나리오에서의 응답 시간, 실패율, 리소스 사용량 등을 측정한다


## 테스트 시나리오

### 토큰 발급 API

- 스크립트
    ```javascript    
    import http from 'k6/http';
    import { check, sleep } from 'k6';
    import { randomIntBetween } from 'https://jslib.k6.io/k6-utils/1.4.0/index.js';
    
    export const options = {
      vus: 100,
      duration: '30s',
      thresholds: {
        http_req_failed: ['rate<0.01'],
        http_req_duration: ['p(95)<200'],
      },
    };
    
    export default function () {
      const userId = randomIntBetween(1, 100);
      const url = `http://192.168.40.149:8080/api/token`;
    
      const payload = JSON.stringify({
          userId: userId
      });
    
      const params = {
          headers: {
              'Content-Type': 'application/json',
          },
      };
    
      const res = http.post(url, payload, params);
    
      check(res, {
          'status is 200': (r) => r.status === 200,
      });
    
      sleep(1);
    }
    ```
- 실행 결과 및 분석
  ![Image](https://github.com/user-attachments/assets/ee6c64f8-574d-4ece-a955-c4b8b8433c21)

    - 총 2796회의 요청을 시도하였으며, 모든 요청이 성공적으로 처리되었습니다.
    - Redis에 665 kB의 데이터가 저장되었으며, 유실된 요청은 없습니다.
    - 평균 응답 시간은 91.41ms로, p95 기준 목표치인 200ms 이내에 모두 수행 완료되었습니다.

### 콘서트 좌석 목록 조회 API (토큰발행 > 토크검증 > 좌석조회)

- 스크립트
  ```javascript    
    import http from 'k6/http';
    import { check, sleep } from 'k6';
    import { randomIntBetween } from 'https://jslib.k6.io/k6-utils/1.4.0/index.js';
    
    export const options = {
      vus: 100,
      duration: '30s',
      thresholds: {
        http_req_failed: ['rate<0.01'],
        http_req_duration: ['p(95)<200'],
      },
    };
    
    export default function () {
      // 1. 사용자 ID 랜덤 생성
      const userId = randomIntBetween(1, 100);
    
      // 2. 토큰 생성 요청
      const tokenUrl = `http://192.168.40.149:8080/api/token`;
      const tokenPayload = JSON.stringify({ userId: userId });
      const tokenParams = {
        headers: {
          'Content-Type': 'application/json',
        },
      };
    
      const tokenRes = http.post(tokenUrl, tokenPayload, tokenParams);
    
      // 3. 토큰 추출
      check(tokenRes, {
        'token request status is 200': (r) => r.status === 200,
      });
    
      const token = tokenRes.json().token;  // 토큰을 응답에서 추출
    
      // 4. 10초 대기
      sleep(15);
    
      // 5. 좌석 조회 요청
      const concertScheduleId = randomIntBetween(1, 10);  // 예시로 1~10 사이의 콘서트 ID 사용
      const seatsUrl = `http://192.168.40.149:8080/api/${concertScheduleId}/available-seats`;
      const seatsParams = {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,  // 생성한 토큰을 헤더에 추가
        },
      };
    
      const seatsRes = http.get(seatsUrl, seatsParams);
    
      // 6. 응답 체크
      check(seatsRes, {
        'available seats request status is 200': (r) => r.status === 200,
      });
    
      sleep(1);
    }
  ```

- 실행 결과 및 분석
  ![Image](https://github.com/user-attachments/assets/e1469b00-721f-4fa0-9b21-638a8c9ee77d)

    - 총 400개의 요청이 발생했으며, 이는 100명의 가상 사용자(VUs)가 30초 동안 반복적으로 요청을 보낸 결과가 보여짐
    - 평균 요청 지연 시간: 129.05ms
      최대 요청 지연 시간: 501.68ms
      p(95): 466.04ms (95번째 백분위수의 요청은 466.04ms가 걸렸습니다.)
      이 지연 시간은 목표(200ms)보다 높습니다. 특히, p(95)가 200ms를 초과하여 성능 개선이 필요함
    - 콘서트 스케줄당 좌석을 1000개를 DB에 넣고, 페이징 처리안하고 조회 하니깐 redis Connection Time이 나왔음
      상기 결과는 스케줄당 좌석을 100개로 세팅하여 테스트 한 결과임
       

### 콘서트 예약 API

- 스크립트
  ```javascript
    import http from 'k6/http';
    import { check, sleep } from 'k6';
    
    export const options = {
      vus: 50,            
      iterations: 50,  
      thresholds: {
        http_req_failed: ['rate<0.1'],
        http_req_duration: ['p(95)<500'],
      }
    };
    
    export default function () {
      const url = 'http://host.docker.internal:8080/api/concerts/reservation';
      const payload = JSON.stringify({
        "concertId":1,
        "scheduleId": 296,
        "userId":2,
        "seatId":33
      });
  
      const params = {
        headers: {
          'Authorization': 'eca61a00-954d-4a88-ade7-d24fbd53d588',
          'Content-Type': 'application/json',
        },
      };
  
      const res = http.post(url, payload, params);
  
      console.log(`Status: ${res.status}`);
      console.log(`Body: ${res.body}`);
      console.log(`Headers: ${JSON.stringify(res.headers)}`);
  
      check(res, {
          'status is 200': (r) => r.status === 200,
      });
    
      sleep(1);
    } 
  ```

- 실행 결과 및 분석
  ![reservation_1](https://github.com/user-attachments/assets/47974143-254b-4e2c-903e-d7216f53b2d0)

    - 총 50회를 시도하였으며, 소요 시간은 p95 기준(500ms)으로는 미달됨
        - 최대 응답 시간은 528.6ms로, 설정한 임계값을 초과함. p95 값이 509.24ms로 나타남
        - 응답 속도 개선 필요
    - http_req_waiting: avg=451.02ms
        - 서버에서 응답을 기다리는 시간으로, http_req_duration의 대부분을 차지. 서버 처리에 시간이 걸리고 있음을 추측
        - http_req_blocked와 http_req_connecting 시간 분석을 통해 네트워크 성능 개선 요구

### 포인트 충전 API

- 스크립트
  ```javascript
  import http from 'k6/http';
  import { check, sleep } from 'k6';
    
  export const options = {
      vus: 10,        
      duration: '5s', 
      thresholds: {
          http_req_failed: ['rate<0.1'], 
          http_req_duration: ['p(95)<200'],
      },
  };
    
  export default function () {
      const userId = 1;
      const url = `http://host.docker.internal:8080/api/users/${userId}/points/charge`;
    
      const payload = JSON.stringify({
          amount: 1000
      });
    
      const params = {
          headers: {
              'Content-Type': 'application/json',
              'Authorization': '96cdc907-fbae-4ebb-8c60-b27fa841b60d',
          },
      }
    
      const res = http.post(url, payload, params);
      
      console.log(`Status: ${res.status}`);
      console.log(`Body: ${res.body}`);
      console.log(`Headers: ${JSON.stringify(res.headers)}`);
        
      check(res, {
          'status is 200': (r) => r.status === 200,
      });
    
      sleep(1);
  }
  ```

- 실행 결과 및 분석
  ![charge_point_1](https://github.com/user-attachments/assets/52818dad-3df4-4c08-8dbd-0ecdd3aff744)
  ![charge_point_2](https://github.com/user-attachments/assets/7ebe001b-a648-4387-837b-8a557d6855ac)

    - 총 50회를 시도하였으며, 모두 p95 기준 목표치 이내 수행 완료
    - 서버 로그로도 50회 충전 완료 금액인 50,000 포인트임을 확인