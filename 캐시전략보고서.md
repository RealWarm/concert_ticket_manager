# [ Cache란 무엇일까? ]

- 데이터를 임시로 복사해두는 Storage 계층
  
- 시간이 오래 걸리는 연산을 미리 수행/저장해서 빨리 가져와서 쓸 수 있게 하는것

- 읽어온 데이터를 '임의의 공간'에 저장하여 나중에 동일한 요청이 오면 DB(또는 API)를
  참조하지 않고 요청을 처리하는 기법
  
- 캐시 서버(Cache Server)는 이때 위에서 말한 임의의 공간이다.  
  클라이언트와 서버 사이에 위치하며 임의로 저장하는 Middlebox로서,  
  다음번 요청시 DB에 요청하지 않고 캐시 서버를 통해서 결과값을  
  빠르게 받을 수 있도록 도와주는 공간이다.  



## [ 왜 사용할까 ? ]
- DB가 버틸 수 있는 최대 요청수 보다 많은 작업이 요청되면 느려질 수 있다.  
  이때 캐시를 사용하면 DB부하를 줄일 수 있고 빠르게 응답 가능하다.


## [ 언제 필요할까 ? ]
- 자주 조회되는 기능을 캐시로 적용
- 원본 데이터에 접근하는 시간이 오래 걸리는 경우 시간을 절약할 수 있다.
- 동일한 입력에 대해서 항상 동일한 결과를 반환하는 기능에 적합하다.
- 데이터 동기화를 자주 시켜야하는 변경이 잦은 데이터는 적합하지 않다.
  요약) 자주 조회되고, 수정이 자주 발생하지 않는 정보들.

- --
# [ 캐시 전략 패턴 ] 

## 1) 캐시 읽기 전략

### [Look Aside = Cache Aside]
- 캐시에서 먼저 찾고 없으면 DB를 조회하고, 그 결과를 캐시에 저장함
- 캐시와 DB가 분리되어 가용되어 캐시 장애 대비 구성이 되어있음.  
  redis가 다운 되더라도 DB에서 데이터를 가져올수 있어 서비스 자체는 가능함  
  하지만 Cache Stampede 현상이 발생함  


### [ Read Through = Inline cache]
- 캐시에서만 읽어온다.
- 캐시와 DB간의 데이터 동기화가 항상 이루어져 데이터 정합성 문제에서 벗어날수 있음  
- 직접적인 데이터베이스 접근을 최소화하고 Read 에 대한 소모되는 자원을 최소화할 수 있음



## 2) 캐시 쓰기 전략

### [ Write Back = Write Behind ]
- 캐시와 DB 동기화를 비동기로하여 동기화 과정이 생략됨
- 캐시에 모아놨다가 DB에 쓰기 때문에 쓰기 비용과 부하를 줄일 수 있음
- Write가 빈번하면서 Read를 하는데 많은 양의 Resource가 소모되는 서비스에 적합
- 캐시에서 오류가 발생하면 데이터를 영구 소실함.

### [ Write Through ]
- 데이터베이스와 Cache에 동시에 데이터를 저장
- 데이터를 저장할 때 먼저 캐시에 저장한 다음! 바로 DB에 저장! (모아놓았다가 나중에 저장이 아닌 바로 저장)
- Read Through 와 마찬가지로 DB 동기화 작업을 캐시에게 위임
- DB와 캐시가 항상 동기화 되어 있어, 데이터는 항상 최신 상태로 유지
- 데이터 유실이 발생하면 안 되는 상황에 적합
- 조건 일단 Cache Store에 저장하기 때문에 캐시에 넣은 데이터를 저장만 하고
  사용하지 않을 가능성이 있어서 리소스 낭비 가능성이 있다

### [ Write Around ]
- 모든 데이터는 DB에 저장 (캐시를 갱신하지 않음)
- Cache miss가 발생하는 경우에만 DB와 캐시에도 데이터를 저장
- 따라서 캐시와 DB 내의 데이터가 다를 수 있음 (데이터 불일치)
- 데이터가 수정, 삭제될 때마다, Cache 또한 삭제하거나 변경해야 하며,
  Cache의 expire를 짧게 조정하는 식으로 대처해야 한다.




## [ Cache Stampede 현상 ]

- key가 만료되는 순간 많은 서버에서 이 key를 같이 보고 있었다면
  모든 어플리케이션 서버에서 DB로 가서 찾게 되는 duplicate read가 발생한다.

- 또 읽어온 값을 각 각 redis에 쓰는 duplicate write도 발생되어,   
  처리량도 다 같이 느려질 뿐 아니라 불필요한 작업이 굉장히 늘어나   
  요청양 폭주로 장애로 이어지는 현상을 말한다.  

- -- 

# [ 캐시 적용과 이유 ]

## 1. 콘서트 목록 조회 [ Read Through ]

  - 목표 : 단순 조회는 redis에서 끝내서 MYSQL에 부하를 안주겠다.

  - 콘서트는 하루 단위로 활성/비활성화를 진행할거라  
  24시에 스케줄로 콘서트 활성화 여부 최신화 후에  
  콘서트 캐시 데이터 교체 작업 할거라 해당 패턴이 적합하다 판단  

  - 콘서트가 많아지면 1~2 페이지만 캐시해놓을 예정


## 2. 콘서트 날짜 조회 [ Read Through ]

  - 목표 : 단순조회는 redis에서 끝내서 MYSQL에 부하를 안주겠다.

  - 콘서트별 스케줄은 많지 않을 것이고, 날짜도 하루 단위로 활성/비활성화  
  시킬 예정임. 24시에 스케줄로 콘서트 날짜 데이터를 교체 할 것이기에  
  해당 전략이 적합하다 판단


## 3. 스케줄 별 좌석 조회 [ Read Through ]

  - 목표 : 좌석들의 상태 정합성을 챙기면서 빠른 조회 성능을 제공한다.

  - redis에서만 조회해서 제공하므로 빠른 조회 결과를 제공함 

  - 고객이 예약을 진행 할 때마다 좌석의 상태를 캐시에 반영하고 바로 DB에 반영하여
  데이터 정합성을 만족하기 위해 해당 전략을 선택
